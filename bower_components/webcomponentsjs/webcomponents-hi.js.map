{"version":3,"sources":["webcomponents-hi-index.js","bower_components/html-imports/src/html-imports.js","src/post-polyfill.js","src/unresolved.js"],"names":["scope","useNative","document","createElement","currentScript","Object","defineProperty","get","readyState","scripts","length","configurable","ABS_URL_TEST","CSS_URL_REGEXP","CSS_IMPORT_REGEXP","STYLESHEET_REGEXP","Path","fixUrls","element","base","href","setAttribute","replaceAttrUrl","getAttribute","src","localName","resolveUrlsInStyle","fixUrlAttributes","attrs","a","i","at","attributes","v","value","search","resolveUrlsInCssText","fixUrlsInTemplates","t$","querySelectorAll","fixUrlsInTemplate","template","content","n$","n","style","linkUrl","textContent","cssText","r","replaceUrls","text","regexp","replace","m","pre","url","post","urlPath","resolveUrl","test","__workingURL","u","URL","pathname","e","doc","__tempDoc","implementation","createHTMLDocument","__base","head","appendChild","__anchor","Xhr","async","load","success","fail","match","pieces","split","header","resource","indexOf","atob","decodeURIComponent","request","XMLHttpRequest","open","onload","redirectedUrl","getResponseHeader","origin","location","protocol","host","response","responseText","status","send","isIE","navigator","userAgent","importSelector","importDisableType","disabledLinkSelector","importDependenciesSelector","importDependencyAttr","rootImportSelector","pendingScriptsSelector","pendingStylesSelector","isImportLink","node","nodeType","Node","ELEMENT_NODE","rel","whenElementLoaded","callback","onLoadingDone","event","removeEventListener","type","addEventListener","whenReady","whenDocumentReady","whenImportsReady","stateChanged","imports","pending","imp","l","importForElement","ownerDocument","parentNode","closest","newCustomEvent","params","window","CustomEvent","createEvent","initCustomEvent","bubbles","cancelable","detail","imps","import","elem","target","constructor","documents","inflight","dynamicImportsMO","MutationObserver","handleMutations","observe","childList","subtree","loadImports","links","loadImport","link","fireEventIfNeeded","makeDocument","processImportsIfLoadingDone","createDocumentFragment","p1","p2","innerHTML","firstChild","baseEl","querySelector","removeAttribute","inlineScriptIndex","num","encodeURIComponent","disconnect","flatten","scriptsOk","stylesOk","fireEvents","waitForStyles","runScripts","DOCUMENT_FRAGMENT_NODE","enumerable","s$","cloneScript","s","clone","j","ll","name","replaceChild","needsMove","placeholder","insertBefore","nextSibling","newSibling","eventType","dispatchEvent","mutations","addedNodes","ii","HTMLImports","customElements","polyfillWrapFlushCallback","runAndClearCallback","flushCallback","cb","origWhenReady","requestAnimationFrame","WebComponents"],"mappings":"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","file":"webcomponents-hi.js","sourcesContent":["(function () {\n'use strict';\n\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(scope => {\n\n  /********************* base setup *********************/\n  const useNative = Boolean('import' in document.createElement('link'));\n\n  // Polyfill `currentScript` for browsers without it.\n  let currentScript = null;\n  if ('currentScript' in document === false) {\n    Object.defineProperty(document, 'currentScript', {\n      get() {\n        return currentScript ||\n          // NOTE: only works when called in synchronously executing code.\n          // readyState should check if `loading` but IE10 is\n          // interactive when scripts run so we cheat. This is not needed by\n          // html-imports polyfill but helps generally polyfill `currentScript`.\n          (document.readyState !== 'complete' ?\n            document.scripts[document.scripts.length - 1] : null);\n      },\n      configurable: true\n    });\n  }\n\n  /********************* path fixup *********************/\n  const ABS_URL_TEST = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n  const CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  const CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  const STYLESHEET_REGEXP = /(<link[^>]*)(rel=['|\"]?stylesheet['|\"]?[^>]*>)/g;\n\n  // path fixup: style elements in imports must be made relative to the main\n  // document. We fixup url's in url() and @import.\n  const Path = {\n\n    fixUrls(element, base) {\n      if (element.href) {\n        element.setAttribute('href',\n          Path.replaceAttrUrl(element.getAttribute('href'), base));\n      }\n      if (element.src) {\n        element.setAttribute('src',\n          Path.replaceAttrUrl(element.getAttribute('src'), base));\n      }\n      if (element.localName === 'style') {\n        Path.resolveUrlsInStyle(element, base);\n      }\n    },\n\n    fixUrlAttributes(element, base) {\n      const attrs = ['action', 'src', 'href', 'url', 'style'];\n      for (let i = 0, a; i < attrs.length && (a = attrs[i]); i++) {\n        const at = element.attributes[a];\n        const v = at && at.value;\n        // Skip bound attribute values (assume binding is done via {} and []).\n        // TODO(valdrin) consider exposing a library-implementable hook.\n        if (v && (v.search(/({{|\\[\\[)/) < 0)) {\n          at.value = (a === 'style') ?\n            Path.resolveUrlsInCssText(v, base) :\n            Path.replaceAttrUrl(v, base);\n        }\n      }\n    },\n\n    fixUrlsInTemplates(element, base) {\n      const t$ = element.querySelectorAll('template');\n      for (let i = 0; i < t$.length; i++) {\n        Path.fixUrlsInTemplate(t$[i], base);\n      }\n    },\n\n    fixUrlsInTemplate(template, base) {\n      // If template is not supported, still resolve urls within it.\n      const content = template.content || template;\n      const n$ = content.querySelectorAll(\n        'style, form[action], [src], [href], [url], [style]');\n      for (let i = 0; i < n$.length; i++) {\n        const n = n$[i];\n        if (n.localName == 'style') {\n          Path.resolveUrlsInStyle(n, base);\n        } else {\n          Path.fixUrlAttributes(n, base);\n        }\n      }\n      Path.fixUrlsInTemplates(content, base);\n    },\n\n    resolveUrlsInStyle(style, linkUrl) {\n      style.textContent = Path.resolveUrlsInCssText(style.textContent, linkUrl);\n    },\n\n    resolveUrlsInCssText(cssText, linkUrl) {\n      let r = Path.replaceUrls(cssText, linkUrl, CSS_URL_REGEXP);\n      r = Path.replaceUrls(r, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n\n    replaceUrls(text, linkUrl, regexp) {\n      return text.replace(regexp, (m, pre, url, post) => {\n        let urlPath = url.replace(/[\"']/g, '');\n        if (linkUrl) {\n          urlPath = Path.resolveUrl(urlPath, linkUrl);\n        }\n        return pre + '\\'' + urlPath + '\\'' + post;\n      });\n    },\n\n    replaceAttrUrl(text, linkUrl) {\n      if (text && ABS_URL_TEST.test(text)) {\n        return text;\n      } else {\n        return Path.resolveUrl(text, linkUrl);\n      }\n    },\n\n    resolveUrl(url, base) {\n      // Lazy feature detection.\n      if (Path.__workingURL === undefined) {\n        Path.__workingURL = false;\n        try {\n          const u = new URL('b', 'http://a');\n          u.pathname = 'c%20d';\n          Path.__workingURL = (u.href === 'http://a/c%20d');\n        } catch (e) {}\n      }\n\n      if (Path.__workingURL) {\n        return (new URL(url, base)).href;\n      }\n\n      // Fallback to creating an anchor into a disconnected document.\n      let doc = Path.__tempDoc;\n      if (!doc) {\n        doc = document.implementation.createHTMLDocument('temp');\n        Path.__tempDoc = doc;\n        doc.__base = doc.createElement('base');\n        doc.head.appendChild(doc.__base);\n        doc.__anchor = doc.createElement('a');\n      }\n      doc.__base.href = base;\n      doc.__anchor.href = url;\n      return doc.__anchor.href || url;\n    }\n  };\n\n  /********************* Xhr processor *********************/\n  const Xhr = {\n\n    async: true,\n\n    /**\n     * @param {!string} url\n     * @param {!function(!string, string=)} success\n     * @param {!function(!string)} fail\n     */\n    load(url, success, fail) {\n      if (!url) {\n        fail('error: href must be specified');\n      } else if (url.match(/^data:/)) {\n        // Handle Data URI Scheme\n        const pieces = url.split(',');\n        const header = pieces[0];\n        let resource = pieces[1];\n        if (header.indexOf(';base64') > -1) {\n          resource = atob(resource);\n        } else {\n          resource = decodeURIComponent(resource);\n        }\n        success(resource);\n      } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, Xhr.async);\n        request.onload = () => {\n          // Servers redirecting an import can add a Location header to help us\n          // polyfill correctly. Handle relative and full paths.\n          let redirectedUrl = request.getResponseHeader('Location');\n          if (redirectedUrl && redirectedUrl.indexOf('/') === 0) {\n            // In IE location.origin might not work\n            // https://connect.microsoft.com/IE/feedback/details/1763802/location-origin-is-undefined-in-ie-11-on-windows-10-but-works-on-windows-7\n            const origin = (location.origin || location.protocol + '//' + location.host);\n            redirectedUrl = origin + redirectedUrl;\n          }\n          const resource = /** @type {string} */ (request.response || request.responseText);\n          if (request.status === 304 || request.status === 0 ||\n            request.status >= 200 && request.status < 300) {\n            success(resource, redirectedUrl);\n          } else {\n            fail(resource);\n          }\n        };\n        request.send();\n      }\n    }\n  };\n\n  /********************* importer *********************/\n\n  const isIE = /Trident/.test(navigator.userAgent) ||\n    /Edge\\/\\d./i.test(navigator.userAgent);\n\n  const importSelector = 'link[rel=import]';\n\n  // Used to disable loading of resources.\n  const importDisableType = 'import-disable';\n\n  const disabledLinkSelector = `link[rel=stylesheet][href][type=${importDisableType}]`;\n\n  const importDependenciesSelector = `${importSelector}, ${disabledLinkSelector},\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type=\"application/javascript\"],\n    script[type=\"text/javascript\"]`;\n\n  const importDependencyAttr = 'import-dependency';\n\n  const rootImportSelector = `${importSelector}:not(${importDependencyAttr})`;\n\n  const pendingScriptsSelector = `script[${importDependencyAttr}]`;\n\n  const pendingStylesSelector = `style[${importDependencyAttr}],\n    link[rel=stylesheet][${importDependencyAttr}]`;\n\n  /**\n   * Importer will:\n   * - load any linked import documents (with deduping)\n   * - whenever an import is loaded, prompt the parser to try to parse\n   * - observe imported documents for new elements (these are handled via the\n   *   dynamic importer)\n   */\n  class Importer {\n    constructor() {\n      this.documents = {};\n      // Used to keep track of pending loads, so that flattening and firing of\n      // events can be done when all resources are ready.\n      this.inflight = 0;\n      this.dynamicImportsMO = new MutationObserver(m => this.handleMutations(m));\n      // 1. Load imports contents\n      // 2. Assign them to first import links on the document\n      // 3. Wait for import styles & scripts to be done loading/running\n      // 4. Fire load/error events\n      whenDocumentReady(() => {\n        // Observe changes on <head>.\n        this.dynamicImportsMO.observe(document.head, {\n          childList: true,\n          subtree: true\n        });\n        this.loadImports(document);\n      });\n    }\n\n    /**\n     * @param {!(HTMLDocument|DocumentFragment|Element)} doc\n     */\n    loadImports(doc) {\n      const links = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      for (let i = 0, l = links.length; i < l; i++) {\n        this.loadImport(links[i]);\n      }\n    }\n\n    /**\n     * @param {!HTMLLinkElement} link\n     */\n    loadImport(link) {\n      const url = link.href;\n      // This resource is already being handled by another import.\n      if (this.documents[url] !== undefined) {\n        // If import is already loaded, we can safely associate it to the link\n        // and fire the load/error event.\n        const imp = this.documents[url];\n        if (imp && imp['__loaded']) {\n          link.import = imp;\n          this.fireEventIfNeeded(link);\n        }\n        return;\n      }\n      this.inflight++;\n      // Mark it as pending to notify others this url is being loaded.\n      this.documents[url] = 'pending';\n      Xhr.load(url, (resource, redirectedUrl) => {\n        const doc = this.makeDocument(resource, redirectedUrl || url);\n        this.documents[url] = doc;\n        this.inflight--;\n        // Load subtree.\n        this.loadImports(doc);\n        this.processImportsIfLoadingDone();\n      }, () => {\n        // If load fails, handle error.\n        this.documents[url] = null;\n        this.inflight--;\n        this.processImportsIfLoadingDone();\n      });\n    }\n\n    /**\n     * Creates a new document containing resource and normalizes urls accordingly.\n     * @param {string=} resource\n     * @param {string=} url\n     * @return {!DocumentFragment}\n     */\n    makeDocument(resource, url) {\n      if (!resource) {\n        return document.createDocumentFragment();\n      }\n\n      if (isIE) {\n        // <link rel=stylesheet> should be appended to <head>. Not doing so\n        // in IE/Edge breaks the cascading order. We disable the loading by\n        // setting the type before setting innerHTML to avoid loading\n        // resources twice.\n        resource = resource.replace(STYLESHEET_REGEXP, (match, p1, p2) => {\n          if (match.indexOf('type=') === -1) {\n            return `${p1} type=${importDisableType} ${p2}`;\n          }\n          return match;\n        });\n      }\n\n      let content;\n      const template = /** @type {!HTMLTemplateElement} */\n        (document.createElement('template'));\n      template.innerHTML = resource;\n      if (template.content) {\n        // This creates issues in Safari10 when used with shadydom (see #12).\n        content = template.content;\n      } else {\n        // <template> not supported, create fragment and move content into it.\n        content = document.createDocumentFragment();\n        while (template.firstChild) {\n          content.appendChild(template.firstChild);\n        }\n      }\n\n      // Support <base> in imported docs. Resolve url and remove its href.\n      const baseEl = content.querySelector('base');\n      if (baseEl) {\n        url = Path.replaceAttrUrl(baseEl.getAttribute('href'), url);\n        baseEl.removeAttribute('href');\n      }\n\n      const n$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)>} */\n        (content.querySelectorAll(importDependenciesSelector));\n      // For source map hints.\n      let inlineScriptIndex = 0;\n      for (let i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {\n        // Listen for load/error events, then fix urls.\n        whenElementLoaded(n);\n        Path.fixUrls(n, url);\n        // Mark for easier selectors.\n        n.setAttribute(importDependencyAttr, '');\n        // Generate source map hints for inline scripts.\n        if (n.localName === 'script' && !n.src && n.textContent) {\n          const num = inlineScriptIndex ? `-${inlineScriptIndex}` : '';\n          const content = n.textContent + `\\n//# sourceURL=${url}${num}.js\\n`;\n          // We use the src attribute so it triggers load/error events, and it's\n          // easier to capture errors (e.g. parsing) like this.\n          n.setAttribute('src', 'data:text/javascript;charset=utf-8,' + encodeURIComponent(content));\n          n.textContent = '';\n          inlineScriptIndex++;\n        }\n      }\n      Path.fixUrlsInTemplates(content, url);\n      return content;\n    }\n\n    /**\n     * Waits for loaded imports to finish loading scripts and styles, then fires\n     * the load/error events.\n     */\n    processImportsIfLoadingDone() {\n      // Wait until all resources are ready, then load import resources.\n      if (this.inflight) {\n        return;\n      }\n\n      // Stop observing, flatten & load resource, then restart observing <head>.\n      this.dynamicImportsMO.disconnect();\n      this.flatten(document);\n      // We wait for styles to load, and at the same time we execute the scripts,\n      // then fire the load/error events for imports to have faster whenReady\n      // callback execution.\n      // NOTE: This is different for native behavior where scripts would be\n      // executed after the styles before them are loaded.\n      // To achieve that, we could select pending styles and scripts in the\n      // document and execute them sequentially in their dom order.\n      let scriptsOk = false,\n        stylesOk = false;\n      const onLoadingDone = () => {\n        if (stylesOk && scriptsOk) {\n          // Restart observing.\n          this.dynamicImportsMO.observe(document.head, {\n            childList: true,\n            subtree: true\n          });\n          this.fireEvents();\n        }\n      };\n      this.waitForStyles(() => {\n        stylesOk = true;\n        onLoadingDone();\n      });\n      this.runScripts(() => {\n        scriptsOk = true;\n        onLoadingDone();\n      });\n    }\n\n    /**\n     * @param {!HTMLDocument} doc\n     */\n    flatten(doc) {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      for (let i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {\n        const imp = this.documents[n.href];\n        n.import = /** @type {!Document} */ (imp);\n        if (imp && imp.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          // We set the .import to be the link itself, and update its readyState.\n          // Other links with the same href will point to this link.\n          this.documents[n.href] = n;\n          n.readyState = 'loading';\n          // Suppress Closure warning about incompatible subtype assignment.\n          ( /** @type {!HTMLElement} */ (n).import = n);\n          // Override baseURI so that link.import.baseURI can be used seemlessly\n          // on native or polyfilled html-imports.\n          Object.defineProperty(n, 'baseURI', {\n            get: () => n.href,\n            configurable: true,\n            enumerable: true\n          });\n          this.flatten(imp);\n          n.appendChild(imp);\n        }\n      }\n    }\n\n    /**\n     * Replaces all the imported scripts with a clone in order to execute them.\n     * Updates the `currentScript`.\n     * @param {!function()} callback\n     */\n    runScripts(callback) {\n      const s$ = document.querySelectorAll(pendingScriptsSelector);\n      const l = s$.length;\n      const cloneScript = i => {\n        if (i < l) {\n          // The pending scripts have been generated through innerHTML and\n          // browsers won't execute them for security reasons. We cannot use\n          // s.cloneNode(true) either, the only way to run the script is manually\n          // creating a new element and copying its attributes.\n          const s = s$[i];\n          const clone = /** @type {!HTMLScriptElement} */\n            (document.createElement('script'));\n          // Remove import-dependency attribute to avoid double cloning.\n          s.removeAttribute(importDependencyAttr);\n          for (let j = 0, ll = s.attributes.length; j < ll; j++) {\n            clone.setAttribute(s.attributes[j].name, s.attributes[j].value);\n          }\n          // Update currentScript and replace original with clone script.\n          currentScript = clone;\n          s.parentNode.replaceChild(clone, s);\n          whenElementLoaded(clone, () => {\n            currentScript = null;\n            cloneScript(i + 1);\n          });\n        } else {\n          callback();\n        }\n      };\n      cloneScript(0);\n    }\n\n    /**\n     * Waits for all the imported stylesheets/styles to be loaded.\n     * @param {!function()} callback\n     */\n    waitForStyles(callback) {\n      const s$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLStyleElement)>} */\n        (document.querySelectorAll(pendingStylesSelector));\n      let pending = s$.length;\n      if (!pending) {\n        callback();\n        return;\n      }\n      // <link rel=stylesheet> should be appended to <head>. Not doing so\n      // in IE/Edge breaks the cascading order\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10472273/\n      // If there is one <link rel=stylesheet> imported, we must move all imported\n      // links and styles to <head>.\n      const needsMove = isIE && !!document.querySelector(disabledLinkSelector);\n      for (let i = 0, l = s$.length, s; i < l && (s = s$[i]); i++) {\n        // Listen for load/error events, remove selector once is done loading.\n        whenElementLoaded(s, () => {\n          s.removeAttribute(importDependencyAttr);\n          if (--pending === 0) {\n            callback();\n          }\n        });\n        // Check if was already moved to head, to handle the case where the element\n        // has already been moved but it is still loading.\n        if (needsMove && s.parentNode !== document.head) {\n          // Replace the element we're about to move with a placeholder.\n          const placeholder = document.createElement(s.localName);\n          // Add reference of the moved element.\n          placeholder['__appliedElement'] = s;\n          // Disable this from appearing in document.styleSheets.\n          placeholder.setAttribute('type', 'import-placeholder');\n          // Append placeholder next to the sibling, and move original to <head>.\n          s.parentNode.insertBefore(placeholder, s.nextSibling);\n          let newSibling = importForElement(s);\n          while (newSibling && importForElement(newSibling)) {\n            newSibling = importForElement(newSibling);\n          }\n          if (newSibling.parentNode !== document.head) {\n            newSibling = null;\n          }\n          document.head.insertBefore(s, newSibling);\n          // Enable the loading of <link rel=stylesheet>.\n          s.removeAttribute('type');\n        }\n      }\n    }\n\n    /**\n     * Fires load/error events for imports in the right order .\n     */\n    fireEvents() {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (document.querySelectorAll(importSelector));\n      // Inverse order to have events firing bottom-up.\n      for (let i = n$.length - 1, n; i >= 0 && (n = n$[i]); i--) {\n        this.fireEventIfNeeded(n);\n      }\n    }\n\n    /**\n     * Fires load/error event for the import if this wasn't done already.\n     * @param {!HTMLLinkElement} link\n     */\n    fireEventIfNeeded(link) {\n      // Don't fire twice same event.\n      if (!link['__loaded']) {\n        link['__loaded'] = true;\n        // Update link's import readyState.\n        link.import && (link.import.readyState = 'complete');\n        const eventType = link.import ? 'load' : 'error';\n        link.dispatchEvent(newCustomEvent(eventType, {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n        }));\n      }\n    }\n\n    /**\n     * @param {Array<MutationRecord>} mutations\n     */\n    handleMutations(mutations) {\n      for (let i = 0; i < mutations.length; i++) {\n        const m = mutations[i];\n        if (!m.addedNodes) {\n          continue;\n        }\n        for (let ii = 0; ii < m.addedNodes.length; ii++) {\n          const elem = m.addedNodes[ii];\n          if (!elem || elem.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n          }\n          // NOTE: added scripts are not updating currentScript in IE.\n          if (isImportLink(elem)) {\n            this.loadImport( /** @type {!HTMLLinkElement} */ (elem));\n          } else {\n            this.loadImports( /** @type {!Element} */ (elem));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   */\n  const isImportLink = node => {\n    return node.nodeType === Node.ELEMENT_NODE && node.localName === 'link' &&\n      ( /** @type {!HTMLLinkElement} */ (node).rel === 'import');\n  };\n\n  /**\n   * Waits for an element to finish loading. If already done loading, it will\n   * mark the element accordingly.\n   * @param {!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)} element\n   * @param {function()=} callback\n   */\n  const whenElementLoaded = (element, callback) => {\n    if (element['__loaded']) {\n      callback && callback();\n    } else if (element.localName === 'script' && !element.src) {\n      // Inline scripts don't trigger load/error events, consider them already loaded.\n      element['__loaded'] = true;\n      callback && callback();\n    } else {\n      const onLoadingDone = event => {\n        element.removeEventListener(event.type, onLoadingDone);\n        element['__loaded'] = true;\n        callback && callback();\n      };\n      element.addEventListener('load', onLoadingDone);\n      // NOTE: We listen only for load events in IE/Edge, because in IE/Edge\n      // <style> with @import will fire error events for each failing @import,\n      // and finally will trigger the load event when all @import are\n      // finished (even if all fail).\n      if (!isIE || element.localName !== 'style') {\n        element.addEventListener('error', onLoadingDone);\n      }\n    }\n  };\n\n  /**\n   * Calls the callback when all imports in the document at call time\n   * (or at least document ready) have loaded. Callback is called synchronously\n   * if imports are already done loading.\n   * @param {function()=} callback\n   */\n  const whenReady = callback => {\n    // 1. ensure the document is in a ready state (has dom), then\n    // 2. watch for loading of imports and call callback when done\n    whenDocumentReady(() => whenImportsReady(() => callback && callback()));\n  };\n\n  /**\n   * Invokes the callback when document is in ready state. Callback is called\n   *  synchronously if document is already done loading.\n   * @param {!function()} callback\n   */\n  const whenDocumentReady = callback => {\n    if (document.readyState !== 'loading') {\n      callback();\n    } else {\n      const stateChanged = () => {\n        if (document.readyState !== 'loading') {\n          document.removeEventListener('readystatechange', stateChanged);\n          callback();\n        }\n      };\n      document.addEventListener('readystatechange', stateChanged);\n    }\n  };\n\n  /**\n   * Invokes the callback after all imports are loaded. Callback is called\n   * synchronously if imports are already done loading.\n   * @param {!function()} callback\n   */\n  const whenImportsReady = callback => {\n    let imports = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(rootImportSelector));\n    let pending = imports.length;\n    if (!pending) {\n      callback();\n      return;\n    }\n    for (let i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n      whenElementLoaded(imp, () => {\n        if (--pending === 0) {\n          callback();\n        }\n      });\n    }\n  };\n\n  /**\n   * Returns the import document containing the element.\n   * @param {!Node} element\n   * @return {HTMLLinkElement|Document|undefined}\n   */\n  const importForElement = element => {\n    if (useNative) {\n      // Return only if not in the main doc!\n      return element.ownerDocument !== document ? element.ownerDocument : null;\n    }\n    let doc = element['__importDoc'];\n    if (!doc && element.parentNode) {\n      doc = /** @type {!Element} */ (element.parentNode);\n      if (typeof doc.closest === 'function') {\n        // Element.closest returns the element itself if it matches the selector,\n        // so we search the closest import starting from the parent.\n        doc = doc.closest(importSelector);\n      } else {\n        // Walk up the parent tree until we find an import.\n        while (!isImportLink(doc) && (doc = doc.parentNode)) {}\n      }\n      element['__importDoc'] = doc;\n    }\n    return doc;\n  };\n\n  const newCustomEvent = (type, params) => {\n    if (typeof window.CustomEvent === 'function') {\n      return new CustomEvent(type, params);\n    }\n    const event = /** @type {!CustomEvent} */ (document.createEvent('CustomEvent'));\n    event.initCustomEvent(type, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n    return event;\n  };\n\n  if (useNative) {\n    // Check for imports that might already be done loading by the time this\n    // script is actually executed. Native imports are blocking, so the ones\n    // available in the document by this time should already have failed\n    // or have .import defined.\n    const imps = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(importSelector));\n    for (let i = 0, l = imps.length, imp; i < l && (imp = imps[i]); i++) {\n      if (!imp.import || imp.import.readyState !== 'loading') {\n        imp['__loaded'] = true;\n      }\n    }\n    // Listen for load/error events to capture dynamically added scripts.\n    /**\n     * @type {!function(!Event)}\n     */\n    const onLoadingDone = event => {\n      const elem = /** @type {!Element} */ (event.target);\n      if (isImportLink(elem)) {\n        elem['__loaded'] = true;\n      }\n    };\n    document.addEventListener('load', onLoadingDone, true /* useCapture */ );\n    document.addEventListener('error', onLoadingDone, true /* useCapture */ );\n  } else {\n    new Importer();\n  }\n\n  /**\n    Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`\n    method. This api is necessary because unlike the native implementation,\n    script elements do not force imports to resolve. Instead, users should wrap\n    code in either an `HTMLImportsLoaded` handler or after load time in an\n    `HTMLImports.whenReady(callback)` call.\n\n    NOTE: This module also supports these apis under the native implementation.\n    Therefore, if this file is loaded, the same code can be used under both\n    the polyfill and native implementation.\n   */\n  whenReady(() => document.dispatchEvent(newCustomEvent('HTMLImportsLoaded', {\n    cancelable: true,\n    bubbles: true,\n    detail: undefined\n  })));\n\n  // exports\n  scope.useNative = useNative;\n  scope.whenReady = whenReady;\n  scope.importForElement = importForElement;\n\n})(window.HTMLImports = (window.HTMLImports || {}));\n\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  'use strict';\n\n  if (customElements && customElements.polyfillWrapFlushCallback) {\n    // Here we ensure that the public `HTMLImports.whenReady`\n    // always comes *after* custom elements have upgraded.\n    let flushCallback;\n    function runAndClearCallback() {\n      if (flushCallback) {\n        let cb = flushCallback;\n        flushCallback = null;\n        cb();\n        return true;\n      }\n    }\n    let origWhenReady = HTMLImports.whenReady;\n    customElements.polyfillWrapFlushCallback(function(cb) {\n      flushCallback = cb;\n      origWhenReady(runAndClearCallback);\n    });\n\n    HTMLImports.whenReady = function(cb) {\n      origWhenReady(function() {\n        // custom element code may add dynamic imports\n        // to match processing of native custom elements before\n        // domContentLoaded, we wait for these imports to resolve first.\n        if (runAndClearCallback()) {\n          HTMLImports.whenReady(cb);\n        } else {\n          cb();\n        }\n      });\n    };\n\n  }\n\n  HTMLImports.whenReady(function() {\n    requestAnimationFrame(function() {\n      window.dispatchEvent(new CustomEvent('WebComponentsReady'));\n    });\n  });\n\n})(window.WebComponents);\n\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // It's desireable to provide a default stylesheet\n  // that's convenient for styling unresolved elements, but\n  // it's cumbersome to have to include this manually in every page.\n  // It would make sense to put inside some HTMLImport but\n  // the HTMLImports polyfill does not allow loading of stylesheets\n  // that block rendering. Therefore this injection is tolerated here.\n  //\n  // NOTE: position: relative fixes IE's failure to inherit opacity\n  // when a child is not statically positioned.\n  var style = document.createElement('style');\n  style.textContent = ''\n      + 'body {'\n      + 'transition: opacity ease-in 0.2s;'\n      + ' } \\n'\n      + 'body[unresolved] {'\n      + 'opacity: 0; display: block; overflow: hidden; position: relative;'\n      + ' } \\n'\n      ;\n  var head = document.querySelector('head');\n  head.insertBefore(style, head.firstChild);\n\n})(window.WebComponents);\n\n/**\n@license\nCopyright (c) 2017 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\n * Polyfills loaded: HTML Imports\n * Used in: Safari Tech Preview\n */\n\n}());\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(scope => {\n\n  /********************* base setup *********************/\n  const useNative = Boolean('import' in document.createElement('link'));\n\n  // Polyfill `currentScript` for browsers without it.\n  let currentScript = null;\n  if ('currentScript' in document === false) {\n    Object.defineProperty(document, 'currentScript', {\n      get() {\n        return currentScript ||\n          // NOTE: only works when called in synchronously executing code.\n          // readyState should check if `loading` but IE10 is\n          // interactive when scripts run so we cheat. This is not needed by\n          // html-imports polyfill but helps generally polyfill `currentScript`.\n          (document.readyState !== 'complete' ?\n            document.scripts[document.scripts.length - 1] : null);\n      },\n      configurable: true\n    });\n  }\n\n  /********************* path fixup *********************/\n  const ABS_URL_TEST = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\n  const CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  const CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  const STYLESHEET_REGEXP = /(<link[^>]*)(rel=['|\"]?stylesheet['|\"]?[^>]*>)/g;\n\n  // path fixup: style elements in imports must be made relative to the main\n  // document. We fixup url's in url() and @import.\n  const Path = {\n\n    fixUrls(element, base) {\n      if (element.href) {\n        element.setAttribute('href',\n          Path.replaceAttrUrl(element.getAttribute('href'), base));\n      }\n      if (element.src) {\n        element.setAttribute('src',\n          Path.replaceAttrUrl(element.getAttribute('src'), base));\n      }\n      if (element.localName === 'style') {\n        Path.resolveUrlsInStyle(element, base);\n      }\n    },\n\n    fixUrlAttributes(element, base) {\n      const attrs = ['action', 'src', 'href', 'url', 'style'];\n      for (let i = 0, a; i < attrs.length && (a = attrs[i]); i++) {\n        const at = element.attributes[a];\n        const v = at && at.value;\n        // Skip bound attribute values (assume binding is done via {} and []).\n        // TODO(valdrin) consider exposing a library-implementable hook.\n        if (v && (v.search(/({{|\\[\\[)/) < 0)) {\n          at.value = (a === 'style') ?\n            Path.resolveUrlsInCssText(v, base) :\n            Path.replaceAttrUrl(v, base);\n        }\n      }\n    },\n\n    fixUrlsInTemplates(element, base) {\n      const t$ = element.querySelectorAll('template');\n      for (let i = 0; i < t$.length; i++) {\n        Path.fixUrlsInTemplate(t$[i], base);\n      }\n    },\n\n    fixUrlsInTemplate(template, base) {\n      // If template is not supported, still resolve urls within it.\n      const content = template.content || template;\n      const n$ = content.querySelectorAll(\n        'style, form[action], [src], [href], [url], [style]');\n      for (let i = 0; i < n$.length; i++) {\n        const n = n$[i];\n        if (n.localName == 'style') {\n          Path.resolveUrlsInStyle(n, base);\n        } else {\n          Path.fixUrlAttributes(n, base);\n        }\n      }\n      Path.fixUrlsInTemplates(content, base);\n    },\n\n    resolveUrlsInStyle(style, linkUrl) {\n      style.textContent = Path.resolveUrlsInCssText(style.textContent, linkUrl);\n    },\n\n    resolveUrlsInCssText(cssText, linkUrl) {\n      let r = Path.replaceUrls(cssText, linkUrl, CSS_URL_REGEXP);\n      r = Path.replaceUrls(r, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n\n    replaceUrls(text, linkUrl, regexp) {\n      return text.replace(regexp, (m, pre, url, post) => {\n        let urlPath = url.replace(/[\"']/g, '');\n        if (linkUrl) {\n          urlPath = Path.resolveUrl(urlPath, linkUrl);\n        }\n        return pre + '\\'' + urlPath + '\\'' + post;\n      });\n    },\n\n    replaceAttrUrl(text, linkUrl) {\n      if (text && ABS_URL_TEST.test(text)) {\n        return text;\n      } else {\n        return Path.resolveUrl(text, linkUrl);\n      }\n    },\n\n    resolveUrl(url, base) {\n      // Lazy feature detection.\n      if (Path.__workingURL === undefined) {\n        Path.__workingURL = false;\n        try {\n          const u = new URL('b', 'http://a');\n          u.pathname = 'c%20d';\n          Path.__workingURL = (u.href === 'http://a/c%20d');\n        } catch (e) {}\n      }\n\n      if (Path.__workingURL) {\n        return (new URL(url, base)).href;\n      }\n\n      // Fallback to creating an anchor into a disconnected document.\n      let doc = Path.__tempDoc;\n      if (!doc) {\n        doc = document.implementation.createHTMLDocument('temp');\n        Path.__tempDoc = doc;\n        doc.__base = doc.createElement('base');\n        doc.head.appendChild(doc.__base);\n        doc.__anchor = doc.createElement('a');\n      }\n      doc.__base.href = base;\n      doc.__anchor.href = url;\n      return doc.__anchor.href || url;\n    }\n  };\n\n  /********************* Xhr processor *********************/\n  const Xhr = {\n\n    async: true,\n\n    /**\n     * @param {!string} url\n     * @param {!function(!string, string=)} success\n     * @param {!function(!string)} fail\n     */\n    load(url, success, fail) {\n      if (!url) {\n        fail('error: href must be specified');\n      } else if (url.match(/^data:/)) {\n        // Handle Data URI Scheme\n        const pieces = url.split(',');\n        const header = pieces[0];\n        let resource = pieces[1];\n        if (header.indexOf(';base64') > -1) {\n          resource = atob(resource);\n        } else {\n          resource = decodeURIComponent(resource);\n        }\n        success(resource);\n      } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, Xhr.async);\n        request.onload = () => {\n          // Servers redirecting an import can add a Location header to help us\n          // polyfill correctly. Handle relative and full paths.\n          let redirectedUrl = request.getResponseHeader('Location');\n          if (redirectedUrl && redirectedUrl.indexOf('/') === 0) {\n            // In IE location.origin might not work\n            // https://connect.microsoft.com/IE/feedback/details/1763802/location-origin-is-undefined-in-ie-11-on-windows-10-but-works-on-windows-7\n            const origin = (location.origin || location.protocol + '//' + location.host);\n            redirectedUrl = origin + redirectedUrl;\n          }\n          const resource = /** @type {string} */ (request.response || request.responseText);\n          if (request.status === 304 || request.status === 0 ||\n            request.status >= 200 && request.status < 300) {\n            success(resource, redirectedUrl);\n          } else {\n            fail(resource);\n          }\n        };\n        request.send();\n      }\n    }\n  };\n\n  /********************* importer *********************/\n\n  const isIE = /Trident/.test(navigator.userAgent) ||\n    /Edge\\/\\d./i.test(navigator.userAgent);\n\n  const importSelector = 'link[rel=import]';\n\n  // Used to disable loading of resources.\n  const importDisableType = 'import-disable';\n\n  const disabledLinkSelector = `link[rel=stylesheet][href][type=${importDisableType}]`;\n\n  const importDependenciesSelector = `${importSelector}, ${disabledLinkSelector},\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type=\"application/javascript\"],\n    script[type=\"text/javascript\"]`;\n\n  const importDependencyAttr = 'import-dependency';\n\n  const rootImportSelector = `${importSelector}:not(${importDependencyAttr})`;\n\n  const pendingScriptsSelector = `script[${importDependencyAttr}]`;\n\n  const pendingStylesSelector = `style[${importDependencyAttr}],\n    link[rel=stylesheet][${importDependencyAttr}]`;\n\n  /**\n   * Importer will:\n   * - load any linked import documents (with deduping)\n   * - whenever an import is loaded, prompt the parser to try to parse\n   * - observe imported documents for new elements (these are handled via the\n   *   dynamic importer)\n   */\n  class Importer {\n    constructor() {\n      this.documents = {};\n      // Used to keep track of pending loads, so that flattening and firing of\n      // events can be done when all resources are ready.\n      this.inflight = 0;\n      this.dynamicImportsMO = new MutationObserver(m => this.handleMutations(m));\n      // 1. Load imports contents\n      // 2. Assign them to first import links on the document\n      // 3. Wait for import styles & scripts to be done loading/running\n      // 4. Fire load/error events\n      whenDocumentReady(() => {\n        // Observe changes on <head>.\n        this.dynamicImportsMO.observe(document.head, {\n          childList: true,\n          subtree: true\n        });\n        this.loadImports(document);\n      });\n    }\n\n    /**\n     * @param {!(HTMLDocument|DocumentFragment|Element)} doc\n     */\n    loadImports(doc) {\n      const links = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      for (let i = 0, l = links.length; i < l; i++) {\n        this.loadImport(links[i]);\n      }\n    }\n\n    /**\n     * @param {!HTMLLinkElement} link\n     */\n    loadImport(link) {\n      const url = link.href;\n      // This resource is already being handled by another import.\n      if (this.documents[url] !== undefined) {\n        // If import is already loaded, we can safely associate it to the link\n        // and fire the load/error event.\n        const imp = this.documents[url];\n        if (imp && imp['__loaded']) {\n          link.import = imp;\n          this.fireEventIfNeeded(link);\n        }\n        return;\n      }\n      this.inflight++;\n      // Mark it as pending to notify others this url is being loaded.\n      this.documents[url] = 'pending';\n      Xhr.load(url, (resource, redirectedUrl) => {\n        const doc = this.makeDocument(resource, redirectedUrl || url);\n        this.documents[url] = doc;\n        this.inflight--;\n        // Load subtree.\n        this.loadImports(doc);\n        this.processImportsIfLoadingDone();\n      }, () => {\n        // If load fails, handle error.\n        this.documents[url] = null;\n        this.inflight--;\n        this.processImportsIfLoadingDone();\n      });\n    }\n\n    /**\n     * Creates a new document containing resource and normalizes urls accordingly.\n     * @param {string=} resource\n     * @param {string=} url\n     * @return {!DocumentFragment}\n     */\n    makeDocument(resource, url) {\n      if (!resource) {\n        return document.createDocumentFragment();\n      }\n\n      if (isIE) {\n        // <link rel=stylesheet> should be appended to <head>. Not doing so\n        // in IE/Edge breaks the cascading order. We disable the loading by\n        // setting the type before setting innerHTML to avoid loading\n        // resources twice.\n        resource = resource.replace(STYLESHEET_REGEXP, (match, p1, p2) => {\n          if (match.indexOf('type=') === -1) {\n            return `${p1} type=${importDisableType} ${p2}`;\n          }\n          return match;\n        });\n      }\n\n      let content;\n      const template = /** @type {!HTMLTemplateElement} */\n        (document.createElement('template'));\n      template.innerHTML = resource;\n      if (template.content) {\n        // This creates issues in Safari10 when used with shadydom (see #12).\n        content = template.content;\n      } else {\n        // <template> not supported, create fragment and move content into it.\n        content = document.createDocumentFragment();\n        while (template.firstChild) {\n          content.appendChild(template.firstChild);\n        }\n      }\n\n      // Support <base> in imported docs. Resolve url and remove its href.\n      const baseEl = content.querySelector('base');\n      if (baseEl) {\n        url = Path.replaceAttrUrl(baseEl.getAttribute('href'), url);\n        baseEl.removeAttribute('href');\n      }\n\n      const n$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)>} */\n        (content.querySelectorAll(importDependenciesSelector));\n      // For source map hints.\n      let inlineScriptIndex = 0;\n      for (let i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {\n        // Listen for load/error events, then fix urls.\n        whenElementLoaded(n);\n        Path.fixUrls(n, url);\n        // Mark for easier selectors.\n        n.setAttribute(importDependencyAttr, '');\n        // Generate source map hints for inline scripts.\n        if (n.localName === 'script' && !n.src && n.textContent) {\n          const num = inlineScriptIndex ? `-${inlineScriptIndex}` : '';\n          const content = n.textContent + `\\n//# sourceURL=${url}${num}.js\\n`;\n          // We use the src attribute so it triggers load/error events, and it's\n          // easier to capture errors (e.g. parsing) like this.\n          n.setAttribute('src', 'data:text/javascript;charset=utf-8,' + encodeURIComponent(content));\n          n.textContent = '';\n          inlineScriptIndex++;\n        }\n      }\n      Path.fixUrlsInTemplates(content, url);\n      return content;\n    }\n\n    /**\n     * Waits for loaded imports to finish loading scripts and styles, then fires\n     * the load/error events.\n     */\n    processImportsIfLoadingDone() {\n      // Wait until all resources are ready, then load import resources.\n      if (this.inflight) {\n        return;\n      }\n\n      // Stop observing, flatten & load resource, then restart observing <head>.\n      this.dynamicImportsMO.disconnect();\n      this.flatten(document);\n      // We wait for styles to load, and at the same time we execute the scripts,\n      // then fire the load/error events for imports to have faster whenReady\n      // callback execution.\n      // NOTE: This is different for native behavior where scripts would be\n      // executed after the styles before them are loaded.\n      // To achieve that, we could select pending styles and scripts in the\n      // document and execute them sequentially in their dom order.\n      let scriptsOk = false,\n        stylesOk = false;\n      const onLoadingDone = () => {\n        if (stylesOk && scriptsOk) {\n          // Restart observing.\n          this.dynamicImportsMO.observe(document.head, {\n            childList: true,\n            subtree: true\n          });\n          this.fireEvents();\n        }\n      }\n      this.waitForStyles(() => {\n        stylesOk = true;\n        onLoadingDone();\n      });\n      this.runScripts(() => {\n        scriptsOk = true;\n        onLoadingDone();\n      });\n    }\n\n    /**\n     * @param {!HTMLDocument} doc\n     */\n    flatten(doc) {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      for (let i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {\n        const imp = this.documents[n.href];\n        n.import = /** @type {!Document} */ (imp);\n        if (imp && imp.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          // We set the .import to be the link itself, and update its readyState.\n          // Other links with the same href will point to this link.\n          this.documents[n.href] = n;\n          n.readyState = 'loading';\n          // Suppress Closure warning about incompatible subtype assignment.\n          ( /** @type {!HTMLElement} */ (n).import = n);\n          // Override baseURI so that link.import.baseURI can be used seemlessly\n          // on native or polyfilled html-imports.\n          Object.defineProperty(n, 'baseURI', {\n            get: () => n.href,\n            configurable: true,\n            enumerable: true\n          });\n          this.flatten(imp);\n          n.appendChild(imp);\n        }\n      }\n    }\n\n    /**\n     * Replaces all the imported scripts with a clone in order to execute them.\n     * Updates the `currentScript`.\n     * @param {!function()} callback\n     */\n    runScripts(callback) {\n      const s$ = document.querySelectorAll(pendingScriptsSelector);\n      const l = s$.length;\n      const cloneScript = i => {\n        if (i < l) {\n          // The pending scripts have been generated through innerHTML and\n          // browsers won't execute them for security reasons. We cannot use\n          // s.cloneNode(true) either, the only way to run the script is manually\n          // creating a new element and copying its attributes.\n          const s = s$[i];\n          const clone = /** @type {!HTMLScriptElement} */\n            (document.createElement('script'));\n          // Remove import-dependency attribute to avoid double cloning.\n          s.removeAttribute(importDependencyAttr);\n          for (let j = 0, ll = s.attributes.length; j < ll; j++) {\n            clone.setAttribute(s.attributes[j].name, s.attributes[j].value);\n          }\n          // Update currentScript and replace original with clone script.\n          currentScript = clone;\n          s.parentNode.replaceChild(clone, s);\n          whenElementLoaded(clone, () => {\n            currentScript = null;\n            cloneScript(i + 1);\n          });\n        } else {\n          callback();\n        }\n      };\n      cloneScript(0);\n    }\n\n    /**\n     * Waits for all the imported stylesheets/styles to be loaded.\n     * @param {!function()} callback\n     */\n    waitForStyles(callback) {\n      const s$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLStyleElement)>} */\n        (document.querySelectorAll(pendingStylesSelector));\n      let pending = s$.length;\n      if (!pending) {\n        callback();\n        return;\n      }\n      // <link rel=stylesheet> should be appended to <head>. Not doing so\n      // in IE/Edge breaks the cascading order\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10472273/\n      // If there is one <link rel=stylesheet> imported, we must move all imported\n      // links and styles to <head>.\n      const needsMove = isIE && !!document.querySelector(disabledLinkSelector);\n      for (let i = 0, l = s$.length, s; i < l && (s = s$[i]); i++) {\n        // Listen for load/error events, remove selector once is done loading.\n        whenElementLoaded(s, () => {\n          s.removeAttribute(importDependencyAttr);\n          if (--pending === 0) {\n            callback();\n          }\n        });\n        // Check if was already moved to head, to handle the case where the element\n        // has already been moved but it is still loading.\n        if (needsMove && s.parentNode !== document.head) {\n          // Replace the element we're about to move with a placeholder.\n          const placeholder = document.createElement(s.localName);\n          // Add reference of the moved element.\n          placeholder['__appliedElement'] = s;\n          // Disable this from appearing in document.styleSheets.\n          placeholder.setAttribute('type', 'import-placeholder');\n          // Append placeholder next to the sibling, and move original to <head>.\n          s.parentNode.insertBefore(placeholder, s.nextSibling);\n          let newSibling = importForElement(s);\n          while (newSibling && importForElement(newSibling)) {\n            newSibling = importForElement(newSibling);\n          }\n          if (newSibling.parentNode !== document.head) {\n            newSibling = null;\n          }\n          document.head.insertBefore(s, newSibling);\n          // Enable the loading of <link rel=stylesheet>.\n          s.removeAttribute('type');\n        }\n      }\n    }\n\n    /**\n     * Fires load/error events for imports in the right order .\n     */\n    fireEvents() {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (document.querySelectorAll(importSelector));\n      // Inverse order to have events firing bottom-up.\n      for (let i = n$.length - 1, n; i >= 0 && (n = n$[i]); i--) {\n        this.fireEventIfNeeded(n);\n      }\n    }\n\n    /**\n     * Fires load/error event for the import if this wasn't done already.\n     * @param {!HTMLLinkElement} link\n     */\n    fireEventIfNeeded(link) {\n      // Don't fire twice same event.\n      if (!link['__loaded']) {\n        link['__loaded'] = true;\n        // Update link's import readyState.\n        link.import && (link.import.readyState = 'complete');\n        const eventType = link.import ? 'load' : 'error';\n        link.dispatchEvent(newCustomEvent(eventType, {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n        }));\n      }\n    }\n\n    /**\n     * @param {Array<MutationRecord>} mutations\n     */\n    handleMutations(mutations) {\n      for (let i = 0; i < mutations.length; i++) {\n        const m = mutations[i];\n        if (!m.addedNodes) {\n          continue;\n        }\n        for (let ii = 0; ii < m.addedNodes.length; ii++) {\n          const elem = m.addedNodes[ii];\n          if (!elem || elem.nodeType !== Node.ELEMENT_NODE) {\n            continue;\n          }\n          // NOTE: added scripts are not updating currentScript in IE.\n          if (isImportLink(elem)) {\n            this.loadImport( /** @type {!HTMLLinkElement} */ (elem));\n          } else {\n            this.loadImports( /** @type {!Element} */ (elem));\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   */\n  const isImportLink = node => {\n    return node.nodeType === Node.ELEMENT_NODE && node.localName === 'link' &&\n      ( /** @type {!HTMLLinkElement} */ (node).rel === 'import');\n  };\n\n  /**\n   * Waits for an element to finish loading. If already done loading, it will\n   * mark the element accordingly.\n   * @param {!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)} element\n   * @param {function()=} callback\n   */\n  const whenElementLoaded = (element, callback) => {\n    if (element['__loaded']) {\n      callback && callback();\n    } else if (element.localName === 'script' && !element.src) {\n      // Inline scripts don't trigger load/error events, consider them already loaded.\n      element['__loaded'] = true;\n      callback && callback();\n    } else {\n      const onLoadingDone = event => {\n        element.removeEventListener(event.type, onLoadingDone);\n        element['__loaded'] = true;\n        callback && callback();\n      };\n      element.addEventListener('load', onLoadingDone);\n      // NOTE: We listen only for load events in IE/Edge, because in IE/Edge\n      // <style> with @import will fire error events for each failing @import,\n      // and finally will trigger the load event when all @import are\n      // finished (even if all fail).\n      if (!isIE || element.localName !== 'style') {\n        element.addEventListener('error', onLoadingDone);\n      }\n    }\n  }\n\n  /**\n   * Calls the callback when all imports in the document at call time\n   * (or at least document ready) have loaded. Callback is called synchronously\n   * if imports are already done loading.\n   * @param {function()=} callback\n   */\n  const whenReady = callback => {\n    // 1. ensure the document is in a ready state (has dom), then\n    // 2. watch for loading of imports and call callback when done\n    whenDocumentReady(() => whenImportsReady(() => callback && callback()));\n  }\n\n  /**\n   * Invokes the callback when document is in ready state. Callback is called\n   *  synchronously if document is already done loading.\n   * @param {!function()} callback\n   */\n  const whenDocumentReady = callback => {\n    if (document.readyState !== 'loading') {\n      callback();\n    } else {\n      const stateChanged = () => {\n        if (document.readyState !== 'loading') {\n          document.removeEventListener('readystatechange', stateChanged);\n          callback();\n        }\n      }\n      document.addEventListener('readystatechange', stateChanged);\n    }\n  }\n\n  /**\n   * Invokes the callback after all imports are loaded. Callback is called\n   * synchronously if imports are already done loading.\n   * @param {!function()} callback\n   */\n  const whenImportsReady = callback => {\n    let imports = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(rootImportSelector));\n    let pending = imports.length;\n    if (!pending) {\n      callback();\n      return;\n    }\n    for (let i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n      whenElementLoaded(imp, () => {\n        if (--pending === 0) {\n          callback();\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the import document containing the element.\n   * @param {!Node} element\n   * @return {HTMLLinkElement|Document|undefined}\n   */\n  const importForElement = element => {\n    if (useNative) {\n      // Return only if not in the main doc!\n      return element.ownerDocument !== document ? element.ownerDocument : null;\n    }\n    let doc = element['__importDoc'];\n    if (!doc && element.parentNode) {\n      doc = /** @type {!Element} */ (element.parentNode);\n      if (typeof doc.closest === 'function') {\n        // Element.closest returns the element itself if it matches the selector,\n        // so we search the closest import starting from the parent.\n        doc = doc.closest(importSelector);\n      } else {\n        // Walk up the parent tree until we find an import.\n        while (!isImportLink(doc) && (doc = doc.parentNode)) {}\n      }\n      element['__importDoc'] = doc;\n    }\n    return doc;\n  }\n\n  const newCustomEvent = (type, params) => {\n    if (typeof window.CustomEvent === 'function') {\n      return new CustomEvent(type, params);\n    }\n    const event = /** @type {!CustomEvent} */ (document.createEvent('CustomEvent'));\n    event.initCustomEvent(type, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n    return event;\n  };\n\n  if (useNative) {\n    // Check for imports that might already be done loading by the time this\n    // script is actually executed. Native imports are blocking, so the ones\n    // available in the document by this time should already have failed\n    // or have .import defined.\n    const imps = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(importSelector));\n    for (let i = 0, l = imps.length, imp; i < l && (imp = imps[i]); i++) {\n      if (!imp.import || imp.import.readyState !== 'loading') {\n        imp['__loaded'] = true;\n      }\n    }\n    // Listen for load/error events to capture dynamically added scripts.\n    /**\n     * @type {!function(!Event)}\n     */\n    const onLoadingDone = event => {\n      const elem = /** @type {!Element} */ (event.target);\n      if (isImportLink(elem)) {\n        elem['__loaded'] = true;\n      }\n    };\n    document.addEventListener('load', onLoadingDone, true /* useCapture */ );\n    document.addEventListener('error', onLoadingDone, true /* useCapture */ );\n  } else {\n    new Importer();\n  }\n\n  /**\n    Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`\n    method. This api is necessary because unlike the native implementation,\n    script elements do not force imports to resolve. Instead, users should wrap\n    code in either an `HTMLImportsLoaded` handler or after load time in an\n    `HTMLImports.whenReady(callback)` call.\n\n    NOTE: This module also supports these apis under the native implementation.\n    Therefore, if this file is loaded, the same code can be used under both\n    the polyfill and native implementation.\n   */\n  whenReady(() => document.dispatchEvent(newCustomEvent('HTMLImportsLoaded', {\n    cancelable: true,\n    bubbles: true,\n    detail: undefined\n  })));\n\n  // exports\n  scope.useNative = useNative;\n  scope.whenReady = whenReady;\n  scope.importForElement = importForElement;\n\n})(window.HTMLImports = (window.HTMLImports || {}));","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  'use strict';\n\n  if (customElements && customElements.polyfillWrapFlushCallback) {\n    // Here we ensure that the public `HTMLImports.whenReady`\n    // always comes *after* custom elements have upgraded.\n    let flushCallback;\n    function runAndClearCallback() {\n      if (flushCallback) {\n        let cb = flushCallback;\n        flushCallback = null;\n        cb();\n        return true;\n      }\n    }\n    let origWhenReady = HTMLImports.whenReady;\n    customElements.polyfillWrapFlushCallback(function(cb) {\n      flushCallback = cb;\n      origWhenReady(runAndClearCallback);\n    });\n\n    HTMLImports.whenReady = function(cb) {\n      origWhenReady(function() {\n        // custom element code may add dynamic imports\n        // to match processing of native custom elements before\n        // domContentLoaded, we wait for these imports to resolve first.\n        if (runAndClearCallback()) {\n          HTMLImports.whenReady(cb);\n        } else {\n          cb();\n        }\n      });\n    }\n\n  }\n\n  HTMLImports.whenReady(function() {\n    requestAnimationFrame(function() {\n      window.dispatchEvent(new CustomEvent('WebComponentsReady'));\n    });\n  });\n\n})(window.WebComponents);\n","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(scope) {\n\n  // It's desireable to provide a default stylesheet\n  // that's convenient for styling unresolved elements, but\n  // it's cumbersome to have to include this manually in every page.\n  // It would make sense to put inside some HTMLImport but\n  // the HTMLImports polyfill does not allow loading of stylesheets\n  // that block rendering. Therefore this injection is tolerated here.\n  //\n  // NOTE: position: relative fixes IE's failure to inherit opacity\n  // when a child is not statically positioned.\n  var style = document.createElement('style');\n  style.textContent = ''\n      + 'body {'\n      + 'transition: opacity ease-in 0.2s;'\n      + ' } \\n'\n      + 'body[unresolved] {'\n      + 'opacity: 0; display: block; overflow: hidden; position: relative;'\n      + ' } \\n'\n      ;\n  var head = document.querySelector('head');\n  head.insertBefore(style, head.firstChild);\n\n})(window.WebComponents);\n"]}